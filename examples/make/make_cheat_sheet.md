# Make Cheat Sheet

Made by approx-error

## Rules

The commands inside a rule is only executed if the target does not exist or the prerequisites/dependencies are newer than the target. Syntax:

```make
target: prerequisite(s)/dependencie(s)
	command1
	command2
```

## Clean

A common keyword (not actually reserved, just a convention) used for deleting outputs generated by running the commands inside rules.
These typically include the object files and the final executable compiled from the source. Clean should not have dependencies and should not be
a file name. Example:

```make
clean:
	rm -f *.o executable
```

## Variables

Variables are and can only be strings.

### Referencing variables

Variables are referenced with the $-sign. There are built in variables and user defined variables in make. Example:

```make
$(some_var)
```

### Defining variables

If you define some variable only once and don't want to change it, you can do so with either the = or := assignment operators. If however your variable definition contains another variable that will
be defined later, use =. If you need to append to a variable later, use :=. Example:


```make
recursive_var = some string $(later_var)
later_var = other string
echo $(recursive_var)
```
Result: some string other string

```make
simply_expanded_var := some string $(later_var)
later_var = other string
echo $(simply_expanded_var)
```
Result: some string

### Automatic variables

```make
$@ = target
```

```make
$? = prerequisites newer than the target
```

```make
$^ = all prerequisites
```

```make
$< = the first prerequisite
```

## Wildcards and patterns

To make sure that the \*-wildcard behaves as expected, use the built in variable \$(wildcard):

```make
wrong := *.o
right := $(wildcard *.o)
```

To substitute stuff for other stuff, use the % wildcard:

```make
obj_files := foo.o bar.o baz.o

$(obj_files): %.o: %.f90
	gfortran -c $^ 
```

```make
source = foo.f90 bar.f90 baz.f90
objects = $(patsubst %.f90, %.o, $(source))
```

If a variable contains multiple file types, use the filter function

```make
source_files = foo.f90 bar.f90 baz.f90 raw.dat log.file
source_code_files = $(filter %.f90, $(source_files))
```

## Make execution

All executed commands on different lines are echoed and executed in a new shell (For example changing the current directory on one line and running a script in that new directory on another will
result in an error since on the new line we are back in the old directory. Thus commands must be on the same line separated by semicolons one wants them to influence each other)

### Command silencing

Command echoing can be silenced by prepending a command with an @-sign. Alternatively commands can be silenced by running make with the -s flag.

### Default shell

The default shell is /bin/sh. It can be changed by modifying the SHELL variable

### Shell variables

If you need to reference a shell variable, make won't know you're doing so since it thinks `$(var)` means some make variable. To make make be able to recognize shell variables, 
use a double dollar sign `$$(shell_var)`.

### Error handling

Run make with the -k flag to run everything despite errors to see all of them at once. Add a - before a make command to suppress any errors (This means the error message will be printed but execution
will still be continued). Run make with the -i flag to add a - before every command.

### Running make recursively

To run make again with the same flags from inside the makefile (Can be useful if you want the Makefile to compile stuff in multiple directories). Use the builtin variable MAKE. It contains the flags used
to run make the first time. For example if make was run with the -s flag. Running echo $(MAKE) will return make -s.
